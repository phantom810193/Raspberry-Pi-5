#!/usr/bin/env python3
"""Convert face embeddings into a lightweight classifier artifact."""
from __future__ import annotations

import argparse
import logging
import pickle
import sys
from pathlib import Path
from typing import List

import numpy as np

ROOT = Path(__file__).resolve().parents[1]
SRC = ROOT / "src"
if SRC.exists():  # pragma: no cover - convenience so scripts work without PYTHONPATH prefix
    sys.path.append(str(SRC))

try:
    from pi_kiosk.detection import hash_descriptor
except Exception:  # pragma: no cover - fallback if module missing
    def hash_descriptor(descriptor: np.ndarray) -> str:
        import hashlib

        byte_view = descriptor.astype(np.float32).tobytes()
        digest = hashlib.sha1(byte_view).hexdigest()
        return "member-" + digest[:12]


LOGGER = logging.getLogger(__name__)


def parse_args(argv: List[str]) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument("--input", type=Path, default=Path("models/known_faces.npz"), help="Input NPZ generated by build_encodings")
    parser.add_argument("--output", type=Path, default=Path("models/face_classifier.pkl"), help="Output classifier pickle path")
    parser.add_argument(
        "--hash-labels",
        action="store_true",
        help="Convert embeddings into匿名 ID (member-xxxx) via hash_descriptor",
    )
    parser.add_argument(
        "--distance-threshold",
        type=float,
        default=0.45,
        help="Distance threshold;推論時若超過則標記為 unknown",
    )
    return parser.parse_args(argv)


def main(argv: List[str]) -> int:
    args = parse_args(argv)
    logging.basicConfig(level=logging.INFO, format="%(levelname)s %(message)s")

    if not args.input.exists():
        LOGGER.error("找不到輸入檔案 %s", args.input)
        return 1

    data = np.load(args.input)
    embeddings = data.get("embeddings")
    labels = data.get("labels")
    if embeddings is None or labels is None:
        LOGGER.error("%s 缺少 embeddings 或 labels 陣列", args.input)
        return 1

    if embeddings.shape[0] != labels.shape[0]:
        LOGGER.error("embeddings 與 labels 數量不一致 (%d != %d)", embeddings.shape[0], labels.shape[0])
        return 1

    if args.hash_labels:
        LOGGER.info("將 %d 個特徵向量轉為匿名 ID", embeddings.shape[0])
        anonymized = [hash_descriptor(embeddings[i]) for i in range(embeddings.shape[0])]
        labels = np.array(anonymized)

    args.output.parent.mkdir(parents=True, exist_ok=True)

    payload = {
        "embeddings": embeddings.astype(np.float32),
        "labels": labels.tolist(),
        "distance_threshold": float(args.distance_threshold),
    }

    with args.output.open("wb") as fh:
        pickle.dump(payload, fh)

    LOGGER.info("已輸出分類器，共 %d 個身份，檔案位於 %s", embeddings.shape[0], args.output)
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv[1:]))
