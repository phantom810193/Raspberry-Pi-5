"""Flask application exposing the advertisement generated by the pipeline."""
from __future__ import annotations

import argparse
import threading
from pathlib import Path
from typing import Optional, Sequence

from flask import Flask, Response, jsonify, render_template_string, request

from .pipeline import AdvertisementPipeline, PipelineConfig, camera_loop, create_pipeline

HTML_TEMPLATE = """
<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title>智慧廣告看板</title>
    <style>
      body { font-family: 'Noto Sans TC', sans-serif; margin: 0; padding: 0; background: #111; color: #fff; }
      .container { display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; text-align: center; }
      h1 { font-size: 3rem; margin-bottom: 1rem; }
      p { font-size: 2rem; line-height: 1.5; max-width: 70vw; }
      .timestamp { font-size: 1rem; margin-top: 2rem; color: #aaa; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>歡迎光臨！</h1>
      <p id="message">等待辨識中...</p>
      <div class="timestamp" id="meta"></div>
    </div>
    <script>
      async function refreshMessage() {
        try {
          const response = await fetch('/api/ad');
          if (!response.ok) return;
          const payload = await response.json();
          document.getElementById('message').textContent = payload.message;
          const metaText = payload.member_id ? `最新會員：${payload.member_id}｜更新時間：${payload.timestamp}` : '';
          document.getElementById('meta').textContent = metaText;
        } catch (error) {
          console.error('failed to refresh message', error);
        }
      }
      setInterval(refreshMessage, 1000);
      refreshMessage();
    </script>
  </body>
</html>
"""


def create_app(pipeline: AdvertisementPipeline) -> Flask:
    app = Flask(__name__)

    @app.route("/")
    def index() -> str:
        return render_template_string(HTML_TEMPLATE)

    @app.route("/api/ad")
    def api_ad() -> Response:
        message, member_id, timestamp = pipeline.latest_message()
        payload = {
            "message": message,
            "member_id": member_id,
            "timestamp": timestamp.isoformat() if timestamp else None,
        }
        return jsonify(payload)

    @app.route("/api/simulate", methods=["POST"])
    def api_simulate() -> Response:
        data = request.get_json(force=True)
        member_id = data.get("member_id")
        if not member_id:
            return jsonify({"error": "member_id missing"}), 400
        message = pipeline.simulate_member(str(member_id))
        return jsonify({"message": message})

    return app


def _start_camera_thread(pipeline: AdvertisementPipeline, camera_index: int, width: Optional[int], height: Optional[int]) -> None:
    thread = threading.Thread(
        target=camera_loop,
        args=(pipeline, camera_index, width, height),
        daemon=True,
        name="camera-loop",
    )
    thread.start()


def parse_args(argv: Optional[Sequence[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Raspberry Pi face recognition advertising kiosk")
    parser.add_argument("--db-path", type=Path, default=Path("data/kiosk.db"), help="SQLite database path")
    parser.add_argument("--model-dir", type=Path, default=Path("models"), help="Directory containing dlib model files")
    parser.add_argument(
        "--classifier",
        type=Path,
        default=None,
        help="Optional classifier pickle produced by scripts/train_classifier.py",
    )
    parser.add_argument("--host", default="0.0.0.0")
    parser.add_argument("--port", type=int, default=8000)
    parser.add_argument("--camera", action="store_true", help="Enable live camera capture")
    parser.add_argument("--camera-index", type=int, default=0)
    parser.add_argument("--frame-width", type=int)
    parser.add_argument("--frame-height", type=int)
    parser.add_argument(
        "--simulate-members",
        nargs="*",
        default=None,
        help="Run without camera using the provided member IDs in a round-robin fashion",
    )
    parser.add_argument("--cooldown-seconds", type=int, default=2, help="Minimum seconds between repeated IDs")
    parser.add_argument(
        "--idle-reset-seconds",
        type=int,
        default=2,
        help="Seconds of inactivity before resetting to the waiting message (0 disables)",
    )
    return parser.parse_args(argv)


def main(argv: Optional[Sequence[str]] = None) -> None:
    args = parse_args(argv)
    config = PipelineConfig(
        db_path=args.db_path,
        model_dir=args.model_dir,
        simulated_member_ids=tuple(args.simulate_members) if args.simulate_members else None,
        cooldown_seconds=args.cooldown_seconds,
        idle_reset_seconds=args.idle_reset_seconds if args.idle_reset_seconds > 0 else None,
        classifier_path=args.classifier,
    )
    pipeline = create_pipeline(config)
    app = create_app(pipeline)

    if args.camera and config.simulated_member_ids is None:
        _start_camera_thread(pipeline, args.camera_index, args.frame_width, args.frame_height)
    elif args.camera and config.simulated_member_ids is not None:
        raise SystemExit("Camera mode cannot be combined with simulated member IDs")

    app.run(host=args.host, port=args.port)


if __name__ == "__main__":  # pragma: no cover
    main()
