"""Flask application exposing the advertisement generated by the pipeline."""
from __future__ import annotations

import argparse
import threading
import base64
import binascii
from pathlib import Path
from typing import Optional, Sequence

from flask import Flask, Response, jsonify, render_template_string, request

import numpy as np

from .database import MemberNotFoundError
from .pipeline import AdvertisementPipeline, PipelineConfig, camera_loop, create_pipeline

HTML_TEMPLATE = """
<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title>智慧廣告看板</title>
    <style>
      body { font-family: 'Noto Sans TC', sans-serif; margin: 0; padding: 0; background: #111; color: #fff; }
      .container { display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; text-align: center; padding: 2rem 1rem; box-sizing: border-box; }
      .frame-container { display: flex; flex-direction: column; align-items: center; gap: 0.75rem; margin-bottom: 2rem; }
      .frame { width: min(90vw, 640px); max-height: 480px; object-fit: contain; border-radius: 1rem; background: #000; box-shadow: 0 16px 45px rgba(0, 0, 0, 0.35); }
      .frame-timestamp { font-size: 1rem; color: #ccc; }
      .status { font-size: 1.1rem; color: #facc15; min-height: 1.5rem; }
      .status:not(.active) { visibility: hidden; }
      h1 { font-size: clamp(2.4rem, 5vw, 3rem); margin-bottom: 1rem; }
      p { font-size: clamp(1.4rem, 4vw, 2rem); line-height: 1.5; max-width: 70vw; margin: 0; }
      .timestamp { font-size: 1rem; margin-top: 2rem; color: #aaa; }
    </style>
  </head>
  <body>
    <div class="container">
      <div class="frame-container">
        <img id="debug-frame" class="frame" alt="最新辨識畫面" hidden />
        <div class="frame-timestamp" id="frame-timestamp">尚未取得畫面</div>
        <div class="status" id="status-indicator" aria-live="polite"></div>
      </div>
      <h1>歡迎光臨！</h1>
      <p id="message">等待辨識中...</p>
      <div class="timestamp" id="meta"></div>
    </div>
    <script>
      function pollDebugFrame(options = {}) {
        const { onFrame, onBusy, onError, interval = 1000 } = options;
        let lastPayload = null;
        let stopped = false;

        async function fetchFrame() {
          if (stopped) {
            return;
          }
          try {
            const response = await fetch('/debug/frame', { cache: 'no-store' });
            if (!response.ok) {
              throw new Error('failed to fetch debug frame');
            }
            const payload = await response.json();
            if (payload.ai_busy) {
              if (typeof onBusy === 'function') {
                onBusy(payload, lastPayload);
              }
              return;
            }
            lastPayload = payload;
            if (typeof onFrame === 'function') {
              onFrame(payload);
            }
          } catch (error) {
            console.error('failed to fetch debug frame', error);
            if (typeof onError === 'function') {
              onError(error);
            }
          }
        }

        fetchFrame();
        const timer = setInterval(fetchFrame, interval);
        return {
          refresh: fetchFrame,
          stop() {
            stopped = true;
            clearInterval(timer);
          },
          getLastPayload() {
            return lastPayload;
          },
        };
      }

      const frameEl = document.getElementById('debug-frame');
      const frameTimestampEl = document.getElementById('frame-timestamp');
      const statusEl = document.getElementById('status-indicator');
      const messageEl = document.getElementById('message');
      const metaEl = document.getElementById('meta');

      function setBusy(isBusy) {
        if (isBusy) {
          statusEl.textContent = 'AI 產生中…請稍候';
          statusEl.classList.add('active');
        } else {
          statusEl.textContent = '';
          statusEl.classList.remove('active');
        }
      }

      pollDebugFrame({
        onFrame(payload) {
          setBusy(false);
          if (payload.image) {
            frameEl.src = payload.image;
            frameEl.hidden = false;
          } else {
            frameEl.removeAttribute('src');
            frameEl.hidden = true;
          }
          frameTimestampEl.textContent = payload.timestamp ? `影像更新：${payload.timestamp}` : '尚未取得畫面';
        },
        onBusy(_payload, lastPayload) {
          setBusy(true);
          if (!lastPayload || !lastPayload.timestamp) {
            frameTimestampEl.textContent = '等待影像更新…';
          }
        },
      });

      async function refreshMessage() {
        try {
          const response = await fetch('/api/ad');
          if (!response.ok) return;
          const payload = await response.json();
          messageEl.textContent = payload.message;
          const metaText = payload.member_id ? `最新會員：${payload.member_id}｜更新時間：${payload.timestamp}` : '';
          metaEl.textContent = metaText;
        } catch (error) {
          console.error('failed to refresh message', error);
        }
      }

      setInterval(refreshMessage, 1000);
      refreshMessage();
    </script>
  </body>
</html>
"""

DEBUG_TEMPLATE = """
<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <title>攝影機除錯視圖</title>
    <style>
      body { font-family: 'Noto Sans TC', sans-serif; margin: 0; padding: 2rem; background: #f8fafc; color: #0f172a; }
      .container { max-width: 960px; margin: 0 auto; }
      h1 { margin-bottom: 1.5rem; font-size: 2rem; }
      .panel { background: white; border-radius: 1rem; box-shadow: 0 12px 25px rgba(15, 23, 42, 0.1); padding: 1.5rem; }
      .frame { width: 100%; max-height: 520px; object-fit: contain; border-radius: 0.75rem; background: #1e293b; }
      pre { background: #0f172a; color: #e2e8f0; padding: 1rem; border-radius: 0.75rem; overflow: auto; }
      .meta { display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; font-size: 0.95rem; color: #475569; gap: 0.75rem; }
      .status { color: #c026d3; font-weight: 600; min-height: 1.2rem; }
      button { background: #2563eb; color: white; border: none; border-radius: 999px; padding: 0.6rem 1.2rem; cursor: pointer; font-size: 0.95rem; }
      button:hover { background: #1d4ed8; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>攝影機偵測偵錯模式</h1>
      <div class="panel">
        <img id="debug-frame" class="frame" alt="debug frame" hidden />
        <div class="meta">
          <span id="debug-timestamp">尚未取得畫面</span>
          <span id="debug-status" class="status" aria-live="polite"></span>
          <button onclick="refreshFrame()">立即更新</button>
        </div>
        <h2>偵測資料</h2>
        <pre id="debug-metadata">尚無偵測資料</pre>
      </div>
    </div>
    <script>
      function pollDebugFrame(options = {}) {
        const { onFrame, onBusy, onError, interval = 1000 } = options;
        let lastPayload = null;
        let stopped = false;

        async function fetchFrame() {
          if (stopped) {
            return;
          }
          try {
            const response = await fetch('/debug/frame', { cache: 'no-store' });
            if (!response.ok) {
              throw new Error('failed to fetch debug frame');
            }
            const payload = await response.json();
            if (payload.ai_busy) {
              if (typeof onBusy === 'function') {
                onBusy(payload, lastPayload);
              }
              return;
            }
            lastPayload = payload;
            if (typeof onFrame === 'function') {
              onFrame(payload);
            }
          } catch (error) {
            console.error('failed to fetch debug frame', error);
            if (typeof onError === 'function') {
              onError(error);
            }
          }
        }

        fetchFrame();
        const timer = setInterval(fetchFrame, interval);
        return {
          refresh: fetchFrame,
          stop() {
            stopped = true;
            clearInterval(timer);
          },
          getLastPayload() {
            return lastPayload;
          },
        };
      }

      const frameEl = document.getElementById('debug-frame');
      const timestampEl = document.getElementById('debug-timestamp');
      const metadataEl = document.getElementById('debug-metadata');
      const statusEl = document.getElementById('debug-status');

      function updateMetadata(metadata) {
        if (metadata && metadata.length) {
          const lines = metadata.map((entry, index) => {
            const distance = entry.distance != null ? entry.distance.toFixed(3) : 'N/A';
            const source = entry.source || 'unknown';
            return `#${index + 1} ID：${entry.label}（來源：${source}）\n距離：${distance}\n方框：(${entry.left}, ${entry.top}) - (${entry.right}, ${entry.bottom})`;
          });
          metadataEl.textContent = lines.join('\n\n');
        } else {
          metadataEl.textContent = '尚無偵測資料';
        }
      }

      const poller = pollDebugFrame({
        onFrame(payload) {
          statusEl.textContent = '';
          if (payload.image) {
            frameEl.src = payload.image;
            frameEl.hidden = false;
          } else {
            frameEl.removeAttribute('src');
            frameEl.hidden = true;
          }
          timestampEl.textContent = payload.timestamp ? `更新時間：${payload.timestamp}` : '尚未取得畫面';
          updateMetadata(payload.metadata);
        },
        onBusy(_payload, lastPayload) {
          statusEl.textContent = 'AI 產生中…請稍候';
          if (lastPayload) {
            if (lastPayload.timestamp) {
              timestampEl.textContent = `更新時間：${lastPayload.timestamp}`;
            }
            if (lastPayload.image) {
              frameEl.src = lastPayload.image;
              frameEl.hidden = false;
            }
            updateMetadata(lastPayload.metadata);
          }
        },
        onError() {
          statusEl.textContent = '無法取得影像';
        },
      });

      function refreshFrame() {
        poller.refresh();
      }
    </script>
  </body>
</html>
"""


def create_app(pipeline: AdvertisementPipeline) -> Flask:
    app = Flask(__name__)

    @app.route("/")
    def index() -> str:
        return render_template_string(HTML_TEMPLATE)

    @app.route("/debug")
    def debug() -> str:
        return render_template_string(DEBUG_TEMPLATE)

    @app.route("/api/ad")
    def api_ad() -> Response:
        message, member_id, timestamp = pipeline.latest_message()
        payload = {
            "message": message,
            "member_id": member_id,
            "timestamp": timestamp.isoformat() if timestamp else None,
        }
        return jsonify(payload)

    @app.route("/api/simulate", methods=["POST"])
    def api_simulate() -> Response:
        data = request.get_json(force=True)
        member_id = data.get("member_id")
        if not member_id:
            return jsonify({"error": "member_id missing"}), 400
        message = pipeline.simulate_member(str(member_id))
        return jsonify({"message": message})

    @app.route("/api/transactions", methods=["POST"])
    def api_transactions() -> Response:
        payload = request.get_json(silent=True)
        if not isinstance(payload, dict):
            return jsonify({"error": "Invalid JSON body"}), 400

        raw_member_id = payload.get("member_id")
        if raw_member_id is None:
            return jsonify({"error": "member_id is required"}), 400
        member_id = str(raw_member_id).strip()
        if not member_id:
            return jsonify({"error": "member_id cannot be empty"}), 400

        transactions_payload = payload.get("transactions")
        if not isinstance(transactions_payload, list) or not transactions_payload:
            return jsonify({"error": "transactions must be a non-empty list"}), 400

        records: list[tuple[str, float, str]] = []
        for index, entry in enumerate(transactions_payload):
            if not isinstance(entry, dict):
                return jsonify({"error": f"transactions[{index}] must be an object"}), 400
            item = entry.get("item")
            amount = entry.get("amount")
            timestamp = entry.get("timestamp")
            if not item or amount is None or not timestamp:
                return jsonify({"error": f"transactions[{index}] missing item/amount/timestamp"}), 400
            try:
                amount_value = float(amount)
            except (TypeError, ValueError):
                return jsonify({"error": f"transactions[{index}].amount must be numeric"}), 400
            records.append((str(item), amount_value, str(timestamp)))

        try:
            inserted = pipeline.add_transactions(member_id, records)
        except MemberNotFoundError:
            return jsonify({"error": "member not found"}), 404

        return jsonify({"member_id": member_id, "inserted": inserted}), 200

    @app.route("/debug/frame")
    def debug_frame() -> Response:
        frame_bytes, metadata, timestamp, ai_busy = pipeline.debug_snapshot()
        if frame_bytes is None:
            payload = {
                "image": None,
                "metadata": metadata,
                "timestamp": timestamp,
                "ai_busy": ai_busy,
            }
            response = jsonify(payload)
            response.headers["Cache-Control"] = "no-store"
            return response

        encoded = base64.b64encode(frame_bytes).decode("ascii")
        payload = {
            "image": f"data:image/jpeg;base64,{encoded}",
            "metadata": metadata,
            "timestamp": timestamp,
            "ai_busy": ai_busy,
        }
        response = jsonify(payload)
        response.headers["Cache-Control"] = "no-store"
        return response

    @app.route("/api/face-features", methods=["POST"])
    def api_add_face_feature() -> Response:
        payload = request.get_json(silent=True)
        if not isinstance(payload, dict):
            return jsonify({"error": "Invalid JSON body"}), 400

        raw_member_id = payload.get("member_id")
        if raw_member_id is None:
            return jsonify({"error": "member_id is required"}), 400
        member_id = str(raw_member_id).strip()
        if not member_id:
            return jsonify({"error": "member_id cannot be empty"}), 400

        descriptor_payload = payload.get("descriptor")
        if not isinstance(descriptor_payload, list):
            return jsonify({"error": "descriptor must be a list of floats"}), 400
        try:
            descriptor = np.array(descriptor_payload, dtype=np.float32)
        except (TypeError, ValueError):
            return jsonify({"error": "descriptor must contain numeric values"}), 400
        if descriptor.ndim != 1 or descriptor.size != 128:
            return jsonify({"error": "descriptor must be a 1D array of length 128"}), 400

        snapshot_data = payload.get("snapshot")
        snapshot: Optional[bytes] = None
        if snapshot_data is not None:
            if not isinstance(snapshot_data, str):
                return jsonify({"error": "snapshot must be a base64 string"}), 400
            try:
                snapshot = base64.b64decode(snapshot_data, validate=True)
            except (binascii.Error, ValueError):
                return jsonify({"error": "snapshot is not valid base64"}), 400

        try:
            pipeline.add_face_feature(member_id, descriptor, snapshot=snapshot)
        except RuntimeError as exc:
            return jsonify({"error": str(exc)}), 400
        except ValueError as exc:
            return jsonify({"error": str(exc)}), 400

        return jsonify({"member_id": member_id, "stored": True}), 201

    @app.route("/api/face-features/<member_id>", methods=["DELETE"])
    def api_delete_face_feature(member_id: str) -> Response:
        member_id = member_id.strip()
        if not member_id:
            return jsonify({"error": "member_id cannot be empty"}), 400
        removed = pipeline.remove_face_feature(member_id)
        if not removed:
            return jsonify({"error": "member_id not found"}), 404
        return jsonify({"member_id": member_id, "removed": True}), 200

    @app.route("/api/face-features", methods=["GET"])
    def api_list_face_features() -> Response:
        member_ids = pipeline.list_face_feature_ids()
        return jsonify({"members": list(member_ids)})

    return app


def _start_camera_thread(pipeline: AdvertisementPipeline, camera_index: int, width: Optional[int], height: Optional[int]) -> None:
    thread = threading.Thread(
        target=camera_loop,
        args=(pipeline, camera_index, width, height),
        daemon=True,
        name="camera-loop",
    )
    thread.start()


def parse_args(argv: Optional[Sequence[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Raspberry Pi face recognition advertising kiosk")
    parser.add_argument("--db-path", type=Path, default=Path("data/kiosk.db"), help="SQLite database path")
    parser.add_argument("--model-dir", type=Path, default=Path("models"), help="Directory containing dlib model files")
    parser.add_argument(
        "--classifier",
        type=Path,
        default=None,
        help="Optional classifier pickle produced by scripts/train_classifier.py",
    )
    parser.add_argument("--host", default="0.0.0.0")
    parser.add_argument("--port", type=int, default=8000)
    parser.add_argument("--camera", action="store_true", help="Enable live camera capture")
    parser.add_argument("--camera-index", type=int, default=0)
    parser.add_argument("--frame-width", type=int)
    parser.add_argument("--frame-height", type=int)
    parser.add_argument(
        "--simulate-members",
        nargs="*",
        default=None,
        help="Run without camera using the provided member IDs in a round-robin fashion",
    )
    parser.add_argument("--cooldown-seconds", type=int, default=2, help="Minimum seconds between repeated IDs")
    parser.add_argument(
        "--idle-reset-seconds",
        type=int,
        default=2,
        help="Seconds of inactivity before resetting to the waiting message (0 disables)",
    )
    parser.add_argument(
        "--no-trained-classifier",
        action="store_true",
        help="Disable loading pre-trained classifier artifacts",
    )
    parser.add_argument(
        "--auto-enroll-first-face",
        action="store_true",
        help="Automatically store the first detected face descriptor to the database",
    )
    parser.add_argument(
        "--auto-enroll-threshold",
        type=float,
        default=0.45,
        help="Distance threshold used for descriptors stored via auto-enroll",
    )
    parser.add_argument(
        "--store-face-snapshot",
        action="store_true",
        help="Persist a JPEG snapshot of the enrolled face in the database",
    )
    return parser.parse_args(argv)


def main(argv: Optional[Sequence[str]] = None) -> None:
    args = parse_args(argv)
    config = PipelineConfig(
        db_path=args.db_path,
        model_dir=args.model_dir,
        simulated_member_ids=tuple(args.simulate_members) if args.simulate_members else None,
        cooldown_seconds=args.cooldown_seconds,
        idle_reset_seconds=args.idle_reset_seconds if args.idle_reset_seconds > 0 else None,
        classifier_path=args.classifier,
        use_trained_classifier=not args.no_trained_classifier,
        auto_enroll_first_face=args.auto_enroll_first_face,
        auto_enroll_threshold=args.auto_enroll_threshold,
        store_face_snapshot=args.store_face_snapshot,
    )
    pipeline = create_pipeline(config)
    app = create_app(pipeline)

    if args.camera and config.simulated_member_ids is None:
        _start_camera_thread(pipeline, args.camera_index, args.frame_width, args.frame_height)
    elif args.camera and config.simulated_member_ids is not None:
        raise SystemExit("Camera mode cannot be combined with simulated member IDs")

    app.run(host=args.host, port=args.port)


if __name__ == "__main__":  # pragma: no cover
    main()
