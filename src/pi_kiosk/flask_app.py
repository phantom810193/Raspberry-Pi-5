"""Flask application exposing the advertisement generated by the pipeline."""
from __future__ import annotations

import argparse
import threading
import base64
import binascii
from pathlib import Path
from typing import Optional, Sequence

from flask import Flask, Response, jsonify, render_template_string, request

import numpy as np

from .database import MemberNotFoundError
from .pipeline import AdvertisementPipeline, PipelineConfig, camera_loop, create_pipeline

HTML_TEMPLATE = """
<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8">
    <title>智慧廣告看板</title>
    <style>
      body { font-family: 'Noto Sans TC', sans-serif; margin: 0; padding: 0; background: #111; color: #fff; }
      .container { display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; text-align: center; }
      h1 { font-size: 3rem; margin-bottom: 1rem; }
      p { font-size: 2rem; line-height: 1.5; max-width: 70vw; }
      .timestamp { font-size: 1rem; margin-top: 2rem; color: #aaa; }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>歡迎光臨！</h1>
      <p id="message">等待辨識中...</p>
      <div class="timestamp" id="meta"></div>
    </div>
    <script>
      async function refreshMessage() {
        try {
          const response = await fetch('/api/ad');
          if (!response.ok) return;
          const payload = await response.json();
          document.getElementById('message').textContent = payload.message;
          const metaText = payload.member_id ? `最新會員：${payload.member_id}｜更新時間：${payload.timestamp}` : '';
          document.getElementById('meta').textContent = metaText;
        } catch (error) {
          console.error('failed to refresh message', error);
        }
      }
      setInterval(refreshMessage, 1000);
      refreshMessage();
    </script>
  </body>
</html>
"""

DEBUG_TEMPLATE = """
<!doctype html>
<html lang=\"zh-Hant\">
  <head>
    <meta charset=\"utf-8\" />
    <title>攝影機除錯視圖</title>
    <style>
      body { font-family: 'Noto Sans TC', sans-serif; margin: 0; padding: 2rem; background: #f8fafc; color: #0f172a; }
      .container { max-width: 960px; margin: 0 auto; }
      h1 { margin-bottom: 1.5rem; font-size: 2rem; }
      .panel { background: white; border-radius: 1rem; box-shadow: 0 12px 25px rgba(15, 23, 42, 0.1); padding: 1.5rem; }
      .frame { width: 100%; max-height: 520px; object-fit: contain; border-radius: 0.75rem; background: #1e293b; }
      pre { background: #0f172a; color: #e2e8f0; padding: 1rem; border-radius: 0.75rem; overflow: auto; }
      .meta { display: flex; justify-content: space-between; align-items: center; margin-top: 1rem; font-size: 0.95rem; color: #475569; }
      button { background: #2563eb; color: white; border: none; border-radius: 999px; padding: 0.6rem 1.2rem; cursor: pointer; font-size: 0.95rem; }
      button:hover { background: #1d4ed8; }
    </style>
  </head>
  <body>
    <div class=\"container\">
      <h1>攝影機偵測偵錯模式</h1>
      <div class=\"panel\">
        <img id=\"debug-frame\" class=\"frame\" alt=\"debug frame\" />
        <div class=\"meta\">
          <span id=\"debug-timestamp\">尚未取得畫面</span>
          <button onclick=\"refreshFrame()\">立即更新</button>
        </div>
        <h2>偵測資料</h2>
        <pre id=\"debug-metadata\">尚無偵測資料</pre>
      </div>
    </div>
    <script>
      async function refreshFrame() {
        try {
          const response = await fetch('/debug/frame');
          if (!response.ok) {
            throw new Error('request failed');
          }
          const payload = await response.json();
          const frameEl = document.getElementById('debug-frame');
          const timestampEl = document.getElementById('debug-timestamp');
          const metadataEl = document.getElementById('debug-metadata');

          if (payload.image) {
            frameEl.src = payload.image;
            timestampEl.textContent = payload.timestamp ? `更新時間：${payload.timestamp}` : '時間未知';
          } else {
            frameEl.removeAttribute('src');
            timestampEl.textContent = '尚未取得畫面';
          }

          if (payload.metadata && payload.metadata.length) {
            metadataEl.textContent = JSON.stringify(payload.metadata, null, 2);
          } else {
            metadataEl.textContent = '尚無偵測資料';
          }
        } catch (error) {
          console.error(error);
        }
      }

      setInterval(refreshFrame, 1000);
      refreshFrame();
    </script>
  </body>
</html>
"""


def create_app(pipeline: AdvertisementPipeline) -> Flask:
    app = Flask(__name__)

    @app.route("/")
    def index() -> str:
        return render_template_string(HTML_TEMPLATE)

    @app.route("/debug")
    def debug() -> str:
        return render_template_string(DEBUG_TEMPLATE)

    @app.route("/api/ad")
    def api_ad() -> Response:
        message, member_id, timestamp = pipeline.latest_message()
        payload = {
            "message": message,
            "member_id": member_id,
            "timestamp": timestamp.isoformat() if timestamp else None,
        }
        return jsonify(payload)

    @app.route("/api/simulate", methods=["POST"])
    def api_simulate() -> Response:
        data = request.get_json(force=True)
        member_id = data.get("member_id")
        if not member_id:
            return jsonify({"error": "member_id missing"}), 400
        message = pipeline.simulate_member(str(member_id))
        return jsonify({"message": message})

    @app.route("/api/transactions", methods=["POST"])
    def api_transactions() -> Response:
        payload = request.get_json(silent=True)
        if not isinstance(payload, dict):
            return jsonify({"error": "Invalid JSON body"}), 400

        raw_member_id = payload.get("member_id")
        if raw_member_id is None:
            return jsonify({"error": "member_id is required"}), 400
        member_id = str(raw_member_id).strip()
        if not member_id:
            return jsonify({"error": "member_id cannot be empty"}), 400

        transactions_payload = payload.get("transactions")
        if not isinstance(transactions_payload, list) or not transactions_payload:
            return jsonify({"error": "transactions must be a non-empty list"}), 400

        records: list[tuple[str, float, str]] = []
        for index, entry in enumerate(transactions_payload):
            if not isinstance(entry, dict):
                return jsonify({"error": f"transactions[{index}] must be an object"}), 400
            item = entry.get("item")
            amount = entry.get("amount")
            timestamp = entry.get("timestamp")
            if not item or amount is None or not timestamp:
                return jsonify({"error": f"transactions[{index}] missing item/amount/timestamp"}), 400
            try:
                amount_value = float(amount)
            except (TypeError, ValueError):
                return jsonify({"error": f"transactions[{index}].amount must be numeric"}), 400
            records.append((str(item), amount_value, str(timestamp)))

        try:
            inserted = pipeline.add_transactions(member_id, records)
        except MemberNotFoundError:
            return jsonify({"error": "member not found"}), 404

        return jsonify({"member_id": member_id, "inserted": inserted}), 200

    @app.route("/debug/frame")
    def debug_frame() -> Response:
        frame_bytes, metadata, timestamp = pipeline.debug_snapshot()
        if frame_bytes is None:
            payload = {"image": None, "metadata": metadata, "timestamp": timestamp}
            response = jsonify(payload)
            response.headers["Cache-Control"] = "no-store"
            return response

        encoded = base64.b64encode(frame_bytes).decode("ascii")
        payload = {
            "image": f"data:image/jpeg;base64,{encoded}",
            "metadata": metadata,
            "timestamp": timestamp,
        }
        response = jsonify(payload)
        response.headers["Cache-Control"] = "no-store"
        return response

    @app.route("/api/face-features", methods=["POST"])
    def api_add_face_feature() -> Response:
        payload = request.get_json(silent=True)
        if not isinstance(payload, dict):
            return jsonify({"error": "Invalid JSON body"}), 400

        raw_member_id = payload.get("member_id")
        if raw_member_id is None:
            return jsonify({"error": "member_id is required"}), 400
        member_id = str(raw_member_id).strip()
        if not member_id:
            return jsonify({"error": "member_id cannot be empty"}), 400

        descriptor_payload = payload.get("descriptor")
        if not isinstance(descriptor_payload, list):
            return jsonify({"error": "descriptor must be a list of floats"}), 400
        try:
            descriptor = np.array(descriptor_payload, dtype=np.float32)
        except (TypeError, ValueError):
            return jsonify({"error": "descriptor must contain numeric values"}), 400
        if descriptor.ndim != 1 or descriptor.size != 128:
            return jsonify({"error": "descriptor must be a 1D array of length 128"}), 400

        snapshot_data = payload.get("snapshot")
        snapshot: Optional[bytes] = None
        if snapshot_data is not None:
            if not isinstance(snapshot_data, str):
                return jsonify({"error": "snapshot must be a base64 string"}), 400
            try:
                snapshot = base64.b64decode(snapshot_data, validate=True)
            except (binascii.Error, ValueError):
                return jsonify({"error": "snapshot is not valid base64"}), 400

        try:
            pipeline.add_face_feature(member_id, descriptor, snapshot=snapshot)
        except RuntimeError as exc:
            return jsonify({"error": str(exc)}), 400
        except ValueError as exc:
            return jsonify({"error": str(exc)}), 400

        return jsonify({"member_id": member_id, "stored": True}), 201

    @app.route("/api/face-features/<member_id>", methods=["DELETE"])
    def api_delete_face_feature(member_id: str) -> Response:
        member_id = member_id.strip()
        if not member_id:
            return jsonify({"error": "member_id cannot be empty"}), 400
        removed = pipeline.remove_face_feature(member_id)
        if not removed:
            return jsonify({"error": "member_id not found"}), 404
        return jsonify({"member_id": member_id, "removed": True}), 200

    @app.route("/api/face-features", methods=["GET"])
    def api_list_face_features() -> Response:
        member_ids = pipeline.list_face_feature_ids()
        return jsonify({"members": list(member_ids)})

    return app


def _start_camera_thread(pipeline: AdvertisementPipeline, camera_index: int, width: Optional[int], height: Optional[int]) -> None:
    thread = threading.Thread(
        target=camera_loop,
        args=(pipeline, camera_index, width, height),
        daemon=True,
        name="camera-loop",
    )
    thread.start()


def parse_args(argv: Optional[Sequence[str]] = None) -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Raspberry Pi face recognition advertising kiosk")
    parser.add_argument("--db-path", type=Path, default=Path("data/kiosk.db"), help="SQLite database path")
    parser.add_argument("--model-dir", type=Path, default=Path("models"), help="Directory containing dlib model files")
    parser.add_argument(
        "--classifier",
        type=Path,
        default=None,
        help="Optional classifier pickle produced by scripts/train_classifier.py",
    )
    parser.add_argument("--host", default="0.0.0.0")
    parser.add_argument("--port", type=int, default=8000)
    parser.add_argument("--camera", action="store_true", help="Enable live camera capture")
    parser.add_argument("--camera-index", type=int, default=0)
    parser.add_argument("--frame-width", type=int)
    parser.add_argument("--frame-height", type=int)
    parser.add_argument(
        "--simulate-members",
        nargs="*",
        default=None,
        help="Run without camera using the provided member IDs in a round-robin fashion",
    )
    parser.add_argument("--cooldown-seconds", type=int, default=2, help="Minimum seconds between repeated IDs")
    parser.add_argument(
        "--idle-reset-seconds",
        type=int,
        default=2,
        help="Seconds of inactivity before resetting to the waiting message (0 disables)",
    )
    parser.add_argument(
        "--no-trained-classifier",
        action="store_true",
        help="Disable loading pre-trained classifier artifacts",
    )
    parser.add_argument(
        "--auto-enroll-first-face",
        action="store_true",
        help="Automatically store the first detected face descriptor to the database",
    )
    parser.add_argument(
        "--auto-enroll-threshold",
        type=float,
        default=0.45,
        help="Distance threshold used for descriptors stored via auto-enroll",
    )
    parser.add_argument(
        "--store-face-snapshot",
        action="store_true",
        help="Persist a JPEG snapshot of the enrolled face in the database",
    )
    return parser.parse_args(argv)


def main(argv: Optional[Sequence[str]] = None) -> None:
    args = parse_args(argv)
    config = PipelineConfig(
        db_path=args.db_path,
        model_dir=args.model_dir,
        simulated_member_ids=tuple(args.simulate_members) if args.simulate_members else None,
        cooldown_seconds=args.cooldown_seconds,
        idle_reset_seconds=args.idle_reset_seconds if args.idle_reset_seconds > 0 else None,
        classifier_path=args.classifier,
        use_trained_classifier=not args.no_trained_classifier,
        auto_enroll_first_face=args.auto_enroll_first_face,
        auto_enroll_threshold=args.auto_enroll_threshold,
        store_face_snapshot=args.store_face_snapshot,
    )
    pipeline = create_pipeline(config)
    app = create_app(pipeline)

    if args.camera and config.simulated_member_ids is None:
        _start_camera_thread(pipeline, args.camera_index, args.frame_width, args.frame_height)
    elif args.camera and config.simulated_member_ids is not None:
        raise SystemExit("Camera mode cannot be combined with simulated member IDs")

    app.run(host=args.host, port=args.port)


if __name__ == "__main__":  # pragma: no cover
    main()
